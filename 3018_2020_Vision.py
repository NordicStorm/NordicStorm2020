#!/usr/bin/env python3

import json
from time import time, sleep # only use the function that gives the current time
import random
import sys

from cscore import CameraServer, VideoSource, UsbCamera, MjpegServer
from networktables import NetworkTablesInstance
import ntcore
import numpy as np
import cv2
from enum import Enum
import statistics
import math
class GripPipeline:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__resize_image_width = 320.0
        self.__resize_image_height = 240.0
        self.__resize_image_interpolation = cv2.INTER_LINEAR

        self.resize_image_output = None

        self.__blur_input = self.resize_image_output
        self.__blur_type = BlurType.Box_Blur
        self.__blur_radius = 2

        self.blur_output = None

        self.__hsl_threshold_input = self.blur_output
        self.__hsl_threshold_hue = [39.53237410071942, 113.20819112627987]
        self.__hsl_threshold_saturation = [32.10431654676259, 255.0]
        self.__hsl_threshold_luminance = [10, 255.0]

        self.hsl_threshold_output = None

        self.__find_contours_input = self.hsl_threshold_output
        self.__find_contours_external_only = False

        self.find_contours_output = None

        self.__filter_contours_contours = self.find_contours_output
        self.__filter_contours_min_area = 60.0
        self.__filter_contours_min_perimeter = 0.0
        self.__filter_contours_min_width = 30.0
        self.__filter_contours_max_width = 500.0
        self.__filter_contours_min_height = 15.0
        self.__filter_contours_max_height = 1000.0
        self.__filter_contours_solidity = [20.68345323741007, 57.09897610921503]
        self.__filter_contours_max_vertices = 235.0
        self.__filter_contours_min_vertices = 30
        self.__filter_contours_min_ratio = 1.25
        self.__filter_contours_max_ratio = 2.9

        self.filter_contours_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        # Step Resize_Image0:
        self.__resize_image_input = source0
        (self.resize_image_output) = self.__resize_image(self.__resize_image_input, self.__resize_image_width, self.__resize_image_height, self.__resize_image_interpolation)

        # Step Blur0:
        self.__blur_input = self.resize_image_output
        (self.blur_output) = self.__blur(self.__blur_input, self.__blur_type, self.__blur_radius)

        # Step HSL_Threshold0:
        self.__hsl_threshold_input = self.blur_output
        (self.hsl_threshold_output) = self.__hsl_threshold(self.__hsl_threshold_input, self.__hsl_threshold_hue, self.__hsl_threshold_saturation, self.__hsl_threshold_luminance)

        # Step Find_Contours0:
        self.__find_contours_input = self.hsl_threshold_output
        (self.find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)

        if debug:black.fill(0)

        # Step Filter_Contours0:
        self.__filter_contours_contours = self.find_contours_output
        (self.filter_contours_output) = self.__filter_contours(self.__filter_contours_contours, self.__filter_contours_min_area, \
                                                               self.__filter_contours_min_perimeter, self.__filter_contours_min_width, \
                                                               self.__filter_contours_max_width, self.__filter_contours_min_height, \
                                                               self.__filter_contours_max_height, self.__filter_contours_solidity, \
                                                               self.__filter_contours_max_vertices, self.__filter_contours_min_vertices, \
                                                               self.__filter_contours_min_ratio, self.__filter_contours_max_ratio)

        if debug:
            output2.putFrame(self.blur_output)
            output3.putFrame(self.hsl_threshold_output)
            output4.putFrame(black)
            black.fill(0)
            cv2.drawContours(black, self.filter_contours_output, -1, (255,255,255), 1)
            output5.putFrame(black)


    @staticmethod
    def __resize_image(input, width, height, interpolation):
        """Scales and image to an exact size.
        Args:
            input: A numpy.ndarray.
            Width: The desired width in pixels.
            Height: The desired height in pixels.
            interpolation: Opencv enum for the type fo interpolation.
        Returns:
            A numpy.ndarray of the new size.
        """
        return cv2.resize(input, ((int)(width), (int)(height)), 0, 0, interpolation)

    @staticmethod
    def __blur(src, type, radius):
        """Softens an image using one of several filters.
        Args:
            src: The source mat (numpy.ndarray).
            type: The blurType to perform represented as an int.
            radius: The radius for the blur as a float.
        Returns:
            A numpy.ndarray that has been blurred.
        """
        if(type is BlurType.Box_Blur):
            ksize = int(2 * round(radius) + 1)
            return cv2.blur(src, (ksize, ksize))
        elif(type is BlurType.Gaussian_Blur):
            ksize = int(6 * round(radius) + 1)
            return cv2.GaussianBlur(src, (ksize, ksize), round(radius))
        elif(type is BlurType.Median_Filter):
            ksize = int(2 * round(radius) + 1)
            return cv2.medianBlur(src, ksize)
        else:
            return cv2.bilateralFilter(src, -1, round(radius), round(radius))

    @staticmethod
    def __hsl_threshold(input, hue, sat, lum):
        """Segment an image based on hue, saturation, and luminance ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max luminance.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HLS)
        return cv2.inRange(out, (hue[0], lum[0], sat[0]),  (hue[1], lum[1], sat[1]))

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        im2, contours, hierarchy =cv2.findContours(input, mode=mode, method=method)
        return contours

    @staticmethod
    def __filter_contours(input_contours, min_area, min_perimeter, min_width, max_width,
                        min_height, max_height, solidity, max_vertex_count, min_vertex_count,
                        min_ratio, max_ratio):
        """Filters out contours that do not meet certain criteria.
        Args:
            input_contours: Contours as a list of numpy.ndarray.
            min_area: The minimum area of a contour that will be kept.
            min_perimeter: The minimum perimeter of a contour that will be kept.
            min_width: Minimum width of a contour.
            max_width: MaxWidth maximum width.
            min_height: Minimum height.
            max_height: Maximimum height.
            solidity: The minimum and maximum solidity of a contour.
            min_vertex_count: Minimum vertex Count of the contours.
            max_vertex_count: Maximum vertex Count.
            min_ratio: Minimum ratio of width to height.
            max_ratio: Maximum ratio of width to height.
        Returns:
            Contours as a list of numpy.ndarray.
        """
        output = []
        for contour in input_contours:
            x,y,w,h = cv2.boundingRect(contour)
            if (w < min_width or w > max_width):
                if debug:cv2.drawContours(black, [contour], -1, (255,0,0), 1)

                continue
            if (h < min_height or h > max_height):
                if debug:cv2.drawContours(black, [contour], -1, (0,255,0), 1)

                continue
            ratio = float(w) / h
            if (ratio < min_ratio or ratio > max_ratio):
                if debug:cv2.drawContours(black, [contour], -1, (255,255,255), 1)
                if debug:print(ratio)
                continue
            area = cv2.contourArea(contour)
            if (area < min_area):
                if debug:cv2.drawContours(black, [contour], -1, (0,0,255), 1)

                continue
            if (cv2.arcLength(contour, True) < min_perimeter):
                if debug:cv2.drawContours(black, [contour], -1, (255,255,0), 1)

                continue
            hull = cv2.convexHull(contour)
            solid = 100 * (area / cv2.contourArea(hull))
            if (solid < solidity[0] or solid > solidity[1]):
                if debug:cv2.drawContours(black, [contour], -1, (0,255,255), 1)
                continue
            if (len(contour) < min_vertex_count or len(contour) > max_vertex_count):
                if debug:print(len(contour))
                if debug:cv2.drawContours(black, [contour], -1, (255,0,255), 1)
                continue
            
            output.append(contour)
        return output

debug=False

BlurType = Enum('BlurType', 'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter')

def processFrame(frame):
    pipeline.process(frame)
    res=pipeline.filter_contours_output
    if len(res)!=0:
        
        return  cv2.boundingRect(res[0])

    else:
        return False

def getRPMAndAngle(distance, origInchesDist):
    distance+=0.74 # account for distance to back hole from target

    velocity, angle = getVelocityAndAngle(distance)
    
    #print("rpm3", rpm)
    rpm=convertVelocityToRPM(velocity)
    #print("orig ", rpm)
    #print ("origang ", angle)



    rpm=applyRPMFudge(rpm)
    angle=applyAngleFudge(angle, rpm)
    #print("rpmfudge: ", fudge)

    #print("anglefudge: ", angleFudge)

    if angle<25:# mechanism can only go to 25 degrees
        print("long")

        angle=25
        x=distance
        y=1.47955 # vertical distance the ball needs to travel
        velocity=getLongshotVelocity(distance, x, y)
        rpm=convertVelocityToRPM(velocity)
        rpm=applyRPMFudgeForLongshot(rpm)
        rpm=1.5114219115073779e+003 +  3.8121729360648424e+000 * origInchesDist
        #rpm=
        if origInchesDist>178.47031876854825:
            print("reallylong")
            x=distance-0.74 # aim for the middle of the big outer target, so move target 0.74m closer
            velocity=getLongshotVelocity(distance, x, y)
            rpm=convertVelocityToRPM(velocity)
            rpm=applyRPMFudgeForVeryLongshot(rpm)


            rpm=2.3973463633773163e+003 + -3.9206380581987790e+000 * origInchesDist +  1.5232575217969729e-002 * origInchesDist*origInchesDist
        #rpm=applyRPMFudge(rpm)
        
        
    if debug:print("vel", velocity)
    if debug:print("rpm", rpm)
    #print("newang", angle)
    return [rpm, angle]
def convertVelocityToRPM(velocity):
    flywheelCircumference=0.319186 # meters


    rpm=velocity/flywheelCircumference
    ratioMultiplier=0.47619
    rpm = rpm*ratioMultiplier # the gears increase the flywheel rpm, so to go back to the motor rpm we need to take 20/42 of it
    rpm=rpm*60 # convert from rpsecond to rpminute

    return rpm
def getLongshotVelocity(distance, x, y):
    radians25 = 0.436332
    c=math.cos(radians25)
    s=math.sin(radians25)
    
    g=9.81
    
    #print("long"),
    v=math.sqrt(((g*x*x)/(2*c*c))*((-1)/(y-((s*x)/c))))

    return v

def applyRPMFudge(rpm):
    return rpm * (3.0541393921880791e+000 - 7.2487484146391550e-004 * rpm)
def applyRPMFudgeForLongshot(rpm):
    #fudge=7.4412442850755873e+000 + -4.7755445685672233e-003 * rpm
    fudge=1.90
    #print("orig:"+str(rpm))

    #print("fudge:"+str(fudge))

    #print("new:"+str(rpm*fudge))
    return rpm * fudge
def applyRPMFudgeForVeryLongshot(rpm):
    fudge=1.8
    #fudge=-4.4268244278918143e+000 +  5.6807972678785852e-003 * rpm


    print("orig:"+str(rpm))
    print("fudge:"+str(fudge))
    print("new:"+str(rpm*fudge))
    return rpm * fudge
def applyAngleFudge(origAngle, rpm):
    angFudge= -1.1306745180644164e+001 +  2.1768502008778193e-003 * rpm
    return origAngle+angFudge
def getVelocityAndAngle(distance):
    g=9.81
    x=distance
    y=1.47955 # vertical distance the ball needs to travel
    
    vyInitial=math.sqrt(2*g*y)
    vxInitial=(g*x)/vyInitial

    velocity=math.sqrt(vyInitial**2+vxInitial**2)# pythagorean theorem
    angle=math.degrees(math.atan(vyInitial/vxInitial))
    return [velocity, angle]

def heightToDistance(h):
    return 5.7349476148636040e+002 +( -1.5554292862671193e+001 * h) +  (1.2522754639035663e-001 * h*h)
def addToRollingAverage(h):
    global averageIndex
    previousSeenHeights[averageIndex]=h
    averageIndex+=1
    if(averageIndex>=windowSize):
        averageIndex=0
def clearAverage():
    global averageIndex
    averageIndex=0
    previousSeenHeights=[0 for i in range(windowSize)]
def getAverageOverRecent():
    return statistics.mean(previousSeenHeights)
averageIndex=0
windowSize=50
previousSeenHeights=[0 for i in range(windowSize)]
if __name__ == "__main__":
    ntinst = NetworkTablesInstance.getDefault()

  
    print("Setting up NetworkTables client for team {}".format(3018))
    ntinst.startClientTeam(3018)
    netOut=ntinst.getTable("vision")

    # get vision camera
    inst = CameraServer.getInstance()
    camera = UsbCamera("rPi Camera 0", "/dev/video0")

    camServer = inst.startAutomaticCapture(camera=camera, return_server=True)
    camera.setConnectionStrategy(VideoSource.ConnectionStrategy.kKeepOpen)
    vidSource=inst.getVideo()
    width=320
    height=240
    camera.setResolution(width, height)
    camera.setExposureManual(5)
    camServer.setCompression(100)
    
    if debug:
        output=inst.putVideo("VisOut",width ,height)
        output2=inst.putVideo("VisOut2",width ,height)
        output3=inst.putVideo("VisOut3",width ,height)
        output4=inst.putVideo("VisOut4",width ,height)
        output5=inst.putVideo("VisOut5",width ,height)
        black = np.zeros(shape=(height, width, 3), dtype=np.uint8)


    frame = np.zeros(shape=(height, width, 3), dtype=np.uint8)

    pipeline=GripPipeline()
    start = time()

    # loop forever on vision program
    while True:
        t, frame = vidSource.grabFrame(frame)
        result=processFrame(frame)
        
        if debug:output.putFrame(frame)

        if debug:print("FPS: {:.1f}".format(1 / (time() - start)))
        #print(camera.isConnected())
        if result:
            x, y, w, h = result
            #h=40
            cx = x+w/2
            cy = y+h/2
            netOut.putNumber("width", w)
            netOut.putNumber("height", h)
            netOut.putNumber("x", cx)
            netOut.putNumber("y", cy)

            
            trueHeight=17# height of target
            
            #correctedHeight=h*0.696 # since we know the angle we are looking at, we can just make this multiplier for perspective be a constant
            #focalLength=289.09
            if debug:print(h)
            if debug:print(correctedHeight)
            #dist = (trueHeight*focalLength) / correctedHeight
            addToRollingAverage(h)
            h=getAverageOverRecent()
            dist = heightToDistance(h)
            origDist=dist
            print (dist)
            #dist=131
            dist+= 3.75 #shooter is behind cam
            dist= dist/39.37 # convert inches to meters
            #print(previousSeenHeights)
            rpm, angle = getRPMAndAngle(dist, origDist)


            if 0 not in previousSeenHeights:
                netOut.putNumber("rpm", rpm)
                netOut.putNumber("angle", angle)
                print("going ", rpm)
            else:
                netOut.putNumber("rpm", -1)
                netOut.putNumber("angle", -1)
        else:
            clearAverage()
            netOut.putNumber("rpm", -1)
            netOut.putNumber("angle", -1)
        start = time()
