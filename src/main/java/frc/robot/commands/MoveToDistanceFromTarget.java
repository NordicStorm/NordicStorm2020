// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import java.util.List;

import frc.robot.Robot;
import frc.robot.Util;
import frc.robot.subsystems.Drivetrain;
import frc.robot.subsystems.PixyObject;

/**
 *
 */
public class MoveToDistanceFromTarget extends Command {

   double targetDistance;
   boolean backward;

   /**
    * 
    * @param targetDistance
    * @param backward Backward means away from target!
    */
    public MoveToDistanceFromTarget(double targetDistance, boolean backward) {

        requires(Robot.drivetrain);
        this.targetDistance=targetDistance;
        this.backward=backward;
    }

    

    @Override
    protected void initialize() {
        Robot.drivetrain.setSuperPMode(false);
        Robot.drivetrain.setOutsideControl(true);
        Robot.drivetrain.setEncMode(true);

    }

    double camWidth=320;
    double offset=6.5;
    double minSpeed = 0.1;
    double maxSpeed = 0.5;
    boolean shouldStop=false;
    
    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        
        double currentDistance=Robot.shooter.getVisionDistance();
        double distanceAway;
        System.out.println("dist:"+currentDistance);

        if(backward){
            distanceAway=targetDistance-currentDistance;
        }else{
            distanceAway=currentDistance-targetDistance;
        }
        if(currentDistance==-1){
            Robot.drivetrain.tankDriveDirect(0, 0);
            return;
        }
        
        if(distanceAway<=0){
            Robot.drivetrain.tankDriveDirect(0, 0);
            if(Math.abs(Robot.drivetrain.getRightEncoderVelocity())<4 && Math.abs(Robot.drivetrain.getLeftEncoderVelocity())<4){
                shouldStop=true;
            }
            return;
        }

        double percentDone=Util.clamp(1-(distanceAway/targetDistance), 0, 1);
        double driveSpeed=(1-percentDone)*0.75;
        
        //System.out.println(percentDone);
        
        if (Math.abs(driveSpeed) < minSpeed) {
            driveSpeed = Math.copySign(minSpeed, driveSpeed);
        }
        if (Math.abs(driveSpeed) > maxSpeed) {
            driveSpeed = Math.copySign(maxSpeed, driveSpeed);
        }
        
        double leftSpeed = driveSpeed;
        double rightSpeed = driveSpeed;

        double currentAngle=Robot.drivetrain.getAngle();

        double target=(camWidth/2)-offset;
        double currentX=Robot.shooter.getVisionXValue();
        double sidewaysCorrection=Math.tan(Math.toRadians(currentAngle))*currentDistance;
        //currentX+=sidewaysCorrection;
        double horizError=currentX-target;
        
        double horizAdjustment=Util.absClamp(horizError*0.02, Math.abs(driveSpeed));//0.01
        System.out.println("target:"+target);
        System.out.println("xOfVision:"+currentX);
        System.out.println("currAng:"+currentAngle);
        System.out.println("perc:"+percentDone);


        double angleDiff=Drivetrain.angleDiff(currentAngle, 0);
        double useDiff=Util.absClamp(angleDiff*0.1, 1);
        double angAdjustment=Util.absClamp(useDiff*0.2*driveSpeed, Math.abs(driveSpeed));//0.01
        percentDone=1;

        double adjustment=(horizAdjustment*(1-percentDone))+(angAdjustment*percentDone);
        
        
        
        leftSpeed+=0.05;
        adjustment=0;
        if(backward){

        }else{
            leftSpeed*=-1;
            rightSpeed*=-1;
        }
        
        leftSpeed+=adjustment;
        rightSpeed-=adjustment;

        //leftSpeed=0;
        //rightSpeed=0;
        //System.out.println("dist:"+currentDistance);

        System.out.println("drivespeed:"+driveSpeed);

        System.out.println("angErr:"+angleDiff);
        System.out.println("horizErr:"+horizError);


        System.out.println("left:"+leftSpeed);
        System.out.println("right:"+rightSpeed);
        
        Robot.drivetrain.tankDriveDirect(-leftSpeed, rightSpeed);

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {

        return shouldStop;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.drivetrain.setOutsideControl(false);
        Robot.drivetrain.drive(0, 0);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }
}
