
// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.commands;

import edu.wpi.first.wpilibj.command.Command;
import frc.robot.Robot;
import frc.robot.subsystems.Drivetrain;

/**
 *
 */
public class DriveArcPath extends PathSection {

   
    
    double robotWidth=1.833; //22 inches = 1.833 feet
    
    double pVal = 0.023;
    double maxTurn = 0.2;
    double minTurn = 0.15;
    double tolerance=2;

    double targetAngle;
    double turnRadius;
    boolean arcRight;
    double mainSpeed;
    double startSpeed;
    double endSpeed;

    double leftSpeedProportion;
    double rightSpeedProportion;
    boolean done=false;

    /**
     * Drive in an arc to an angle. 
     * @param targetAngle target angle
     * @param turnRadius turn radius in feet. Measured from the inside wheel towards the center of the arc.
     * @param speed speed. -1 to 1. 
     * @param arcRight Affects to which side the robot will arc.
     * If true, will arc to the right, if false it will go left.
     */
    public DriveArcPath(double targetAngle, double turnRadius, double speed, boolean arcRight) {
        this.targetAngle=targetAngle;
        this.turnRadius=turnRadius;
        this.mainSpeed=speed;
        this.arcRight=arcRight;

        requires(Robot.drivetrain);

        double radLeft;
        double radRight;

        if(arcRight){
            radLeft=turnRadius+robotWidth;
            radRight=turnRadius;

            double circLeft=2*Math.PI*radLeft;
            double circRight=2*Math.PI*radRight;
            leftSpeedProportion=1;
            rightSpeedProportion=circRight/circLeft;
        }else{
            radLeft=turnRadius;
            radRight=turnRadius+robotWidth;

            double circLeft=2*Math.PI*radLeft;
            double circRight=2*Math.PI*radRight;
            leftSpeedProportion=circLeft/circRight;
            rightSpeedProportion=1;
        }
        
        

    }

    @Override
    protected void initialize() {
        Robot.drivetrain.setEncMode(true);
        Robot.drivetrain.setSuperPMode(true);
        //leftTargetPos=Robot.drivetrain.getLeftEncoderDistance()-distance;
        //rightTargetPos=Robot.drivetrain.getRightEncoderDistance()+distance;
        Robot.drivetrain.setOutsideControl(true);
        done=false;
    }
    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        double currentAngle = Robot.drivetrain.getAngle();
        double angDiff=Drivetrain.fullAngleDiff(currentAngle, targetAngle, arcRight);
        double driveSpeed=0.5;//Math.min(Math.max(angDiff*0.02, 0), 1);
        System.out.println("drivespeed"+driveSpeed);
        System.out.println("leftProp"+ leftSpeedProportion);
        System.out.println("rightProp"+ rightSpeedProportion);
        double leftSpeed= -driveSpeed*leftSpeedProportion;
        double rightSpeed = driveSpeed*rightSpeedProportion;
        Robot.drivetrain.tankDriveDirect(leftSpeed, rightSpeed);
        if(angDiff<0
         && Math.abs(Robot.drivetrain.getLeftEncoderVelocity())<12
         && Math.abs(Robot.drivetrain.getRightEncoderVelocity())<12){
            done=true;
        }
    }

    
    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return done;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.drivetrain.setSuperPMode(false);
        Robot.drivetrain.setOutsideControl(false);
        Robot.drivetrain.drive(0, 0);
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        end();
    }

    @Override
    public double getNeededStartSpeed() {
        return startSpeed;
    }

    @Override
    public void finalizeForPath(PathSection previous, PathSection next) {

    }
}
